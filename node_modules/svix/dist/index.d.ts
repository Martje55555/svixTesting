import { Configuration, ApplicationOut, ListResponseApplicationOut, ApplicationIn, ListResponseEndpointOut, EndpointOut, EndpointIn, EndpointSecretOut, MessageOut, MessageIn, ListResponseMessageOut, DashboardAccessOut, ListResponseEndpointMessageOut, ListResponseMessageEndpointOut, ListResponseMessageAttemptEndpointOut, ListResponseMessageAttemptOut, MessageAttemptOut, MessageStatus, ListResponseEventTypeOut, EventTypeIn, EventTypeOut, EventTypeUpdate } from "./openapi/index";
export * from "./openapi/models/all";
export * from "./openapi/apis/exception";
export interface SvixOptions {
    debug?: boolean;
}
export declare class Svix {
    readonly _configuration: Configuration;
    readonly authentication: Authentication;
    readonly application: Application;
    readonly endpoint: Endpoint;
    readonly eventType: EventType;
    readonly message: Message;
    readonly messageAttempt: MessageAttempt;
    constructor(token: string, options?: SvixOptions);
}
declare class Authentication {
    private readonly api;
    constructor(config: Configuration);
    dashboardAccess(appId: string): Promise<DashboardAccessOut>;
    logout(): Promise<void>;
}
export interface FetchOptions {
    iterator?: string;
    limit?: number;
}
declare class Application {
    private readonly api;
    constructor(config: Configuration);
    list(options?: FetchOptions): Promise<ListResponseApplicationOut>;
    create(applicationIn: ApplicationIn): Promise<ApplicationOut>;
    get(appId: string): Promise<ApplicationOut>;
    update(appId: string, applicationIn: ApplicationIn): Promise<ApplicationOut>;
    delete(appId: string): Promise<void>;
}
declare class Endpoint {
    private readonly api;
    constructor(config: Configuration);
    list(appId: string, options?: FetchOptions): Promise<ListResponseEndpointOut>;
    create(appId: string, endpointIn: EndpointIn): Promise<EndpointOut>;
    get(appId: string, endpointId: string): Promise<EndpointOut>;
    update(appId: string, endpointId: string, endpointIn: EndpointIn): Promise<EndpointOut>;
    delete(appId: string, endpointId: string): Promise<void>;
    getSecret(appId: string, endpointId: string): Promise<EndpointSecretOut>;
}
declare class EventType {
    private readonly api;
    constructor(config: Configuration);
    list(options?: FetchOptions): Promise<ListResponseEventTypeOut>;
    create(eventTypeIn: EventTypeIn): Promise<EventTypeOut>;
    update(eventTypeName: string, eventTypeUpdate: EventTypeUpdate): Promise<EventTypeOut>;
    delete(eventTypeName: string): Promise<void>;
}
declare class Message {
    private readonly api;
    constructor(config: Configuration);
    list(appId: string, options?: FetchOptions): Promise<ListResponseMessageOut>;
    create(appId: string, messageIn: MessageIn): Promise<MessageOut>;
    get(appId: string, msgId: string): Promise<MessageOut>;
}
export interface FetchOptionsMessageAttempt extends FetchOptions {
    status?: MessageStatus;
}
declare class MessageAttempt {
    private readonly api;
    constructor(config: Configuration);
    list(appId: string, msgId: string, options?: FetchOptionsMessageAttempt): Promise<ListResponseMessageAttemptOut>;
    get(appId: string, msgId: string, attemptId: string): Promise<MessageAttemptOut>;
    resend(appId: string, msgId: string, endpointId: string): Promise<void>;
    listAttemptedMessages(appId: string, endpointId: string, options?: FetchOptionsMessageAttempt): Promise<ListResponseEndpointMessageOut>;
    listAttemptedDestinations(appId: string, msgId: string, options?: FetchOptionsMessageAttempt): Promise<ListResponseMessageEndpointOut>;
    listAttemptsForEndpoint(appId: string, msgId: string, endpointId: string, options?: FetchOptionsMessageAttempt): Promise<ListResponseMessageAttemptEndpointOut>;
}
declare class ExtendableError extends Error {
    constructor(message: any);
}
export declare class WebhookVerificationError extends ExtendableError {
    constructor(message: string);
}
export interface WebhookRequiredHeaders {
    "svix-id": string;
    "svix-timestamp": string;
    "svix-signature": string;
}
export declare class Webhook {
    private static prefix;
    private readonly key;
    constructor(secret: string);
    verify(payload: string, headers_: WebhookRequiredHeaders | Record<string, string>): unknown;
    sign(msgId: string, timestamp: Date, payload: string): string;
    private verifyTimestamp;
}
